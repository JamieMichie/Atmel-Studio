
SerConsole.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004a  00800100  0000068a  0000071e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000068a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000034  0080014a  0080014a  00000768  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000768  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000798  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  000007d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000d3d  00000000  00000000  00000858  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000aec  00000000  00000000  00001595  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005e1  00000000  00000000  00002081  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001f8  00000000  00000000  00002664  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005c7  00000000  00000000  0000285c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000040d  00000000  00000000  00002e23  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  00003230  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  28:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  2c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  30:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  44:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  48:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  54:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  58:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  5c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  60:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  64:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__vector_25>
  68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  78:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  80:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  8c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  90:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  94:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  98:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  9c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	da e0       	ldi	r29, 0x0A	; 10
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
  b8:	11 e0       	ldi	r17, 0x01	; 1
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	ea e8       	ldi	r30, 0x8A	; 138
  c0:	f6 e0       	ldi	r31, 0x06	; 6
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
  c4:	05 90       	lpm	r0, Z+
  c6:	0d 92       	st	X+, r0
  c8:	aa 34       	cpi	r26, 0x4A	; 74
  ca:	b1 07       	cpc	r27, r17
  cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
  ce:	21 e0       	ldi	r18, 0x01	; 1
  d0:	aa e4       	ldi	r26, 0x4A	; 74
  d2:	b1 e0       	ldi	r27, 0x01	; 1
  d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
  d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
  d8:	ae 37       	cpi	r26, 0x7E	; 126
  da:	b2 07       	cpc	r27, r18
  dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
  de:	0e 94 ad 02 	call	0x55a	; 0x55a <main>
  e2:	0c 94 43 03 	jmp	0x686	; 0x686 <_exit>

000000e6 <__bad_interrupt>:
  e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <__iCliRetVal>:
    sei();
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
  ea:	cf 93       	push	r28
  ec:	df 93       	push	r29
  ee:	cd b7       	in	r28, 0x3d	; 61
  f0:	de b7       	in	r29, 0x3e	; 62
    cli();
  f2:	f8 94       	cli
    return 1;
  f4:	81 e0       	ldi	r24, 0x01	; 1
}
  f6:	df 91       	pop	r29
  f8:	cf 91       	pop	r28
  fa:	08 95       	ret

000000fc <__iSeiParam>:

static __inline__ void __iSeiParam(const uint8_t *__s)
{
  fc:	cf 93       	push	r28
  fe:	df 93       	push	r29
 100:	00 d0       	rcall	.+0      	; 0x102 <__iSeiParam+0x6>
 102:	cd b7       	in	r28, 0x3d	; 61
 104:	de b7       	in	r29, 0x3e	; 62
 106:	9a 83       	std	Y+2, r25	; 0x02
 108:	89 83       	std	Y+1, r24	; 0x01
    sei();
 10a:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}
 10c:	00 00       	nop
 10e:	0f 90       	pop	r0
 110:	0f 90       	pop	r0
 112:	df 91       	pop	r29
 114:	cf 91       	pop	r28
 116:	08 95       	ret

00000118 <uart_init>:
void print_val(char id, int value);
int parse_assignment(void);
int16_t parse_query(void);


void uart_init(void){
 118:	cf 93       	push	r28
 11a:	df 93       	push	r29
 11c:	cd b7       	in	r28, 0x3d	; 61
 11e:	de b7       	in	r29, 0x3e	; 62
	//Function to configure uart port 1 for asynchronous serial communication
	// PD2 = RXD1 PD3 = TXD1
	
	//enable receiver and transmitter
	UCSR1B |= (1 << RXEN1) | (1 << TXEN1);
 120:	89 ec       	ldi	r24, 0xC9	; 201
 122:	90 e0       	ldi	r25, 0x00	; 0
 124:	29 ec       	ldi	r18, 0xC9	; 201
 126:	30 e0       	ldi	r19, 0x00	; 0
 128:	f9 01       	movw	r30, r18
 12a:	20 81       	ld	r18, Z
 12c:	28 61       	ori	r18, 0x18	; 24
 12e:	fc 01       	movw	r30, r24
 130:	20 83       	st	Z, r18
	//Set frame format 8bit, 1 stop bits
	UCSR1C = (1 << UCSZ10) | (1 << UCSZ11);
 132:	8a ec       	ldi	r24, 0xCA	; 202
 134:	90 e0       	ldi	r25, 0x00	; 0
 136:	26 e0       	ldi	r18, 0x06	; 6
 138:	fc 01       	movw	r30, r24
 13a:	20 83       	st	Z, r18
	UCSR1B |=  (1 << RXCIE1);
 13c:	89 ec       	ldi	r24, 0xC9	; 201
 13e:	90 e0       	ldi	r25, 0x00	; 0
 140:	29 ec       	ldi	r18, 0xC9	; 201
 142:	30 e0       	ldi	r19, 0x00	; 0
 144:	f9 01       	movw	r30, r18
 146:	20 81       	ld	r18, Z
 148:	20 68       	ori	r18, 0x80	; 128
 14a:	fc 01       	movw	r30, r24
 14c:	20 83       	st	Z, r18
	UBRR1H = (unsigned char)(PRESCALER >> 8);
 14e:	8d ec       	ldi	r24, 0xCD	; 205
 150:	90 e0       	ldi	r25, 0x00	; 0
 152:	fc 01       	movw	r30, r24
 154:	10 82       	st	Z, r1
	UBRR1L = (unsigned char)(PRESCALER);
 156:	8c ec       	ldi	r24, 0xCC	; 204
 158:	90 e0       	ldi	r25, 0x00	; 0
 15a:	27 e6       	ldi	r18, 0x67	; 103
 15c:	fc 01       	movw	r30, r24
 15e:	20 83       	st	Z, r18
	sei();
 160:	78 94       	sei
}
 162:	00 00       	nop
 164:	df 91       	pop	r29
 166:	cf 91       	pop	r28
 168:	08 95       	ret

0000016a <usart_putc>:
void usart_putc(const char cdata){
 16a:	cf 93       	push	r28
 16c:	df 93       	push	r29
 16e:	1f 92       	push	r1
 170:	cd b7       	in	r28, 0x3d	; 61
 172:	de b7       	in	r29, 0x3e	; 62
 174:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while(!(UCSR1A & (1<<UDRE1)))
 176:	00 00       	nop
 178:	88 ec       	ldi	r24, 0xC8	; 200
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	fc 01       	movw	r30, r24
 17e:	80 81       	ld	r24, Z
 180:	88 2f       	mov	r24, r24
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	80 72       	andi	r24, 0x20	; 32
 186:	99 27       	eor	r25, r25
 188:	89 2b       	or	r24, r25
 18a:	b1 f3       	breq	.-20     	; 0x178 <usart_putc+0xe>
	;
	/*Put data into the buffer and send */
	UDR1 = cdata;
 18c:	8e ec       	ldi	r24, 0xCE	; 206
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	29 81       	ldd	r18, Y+1	; 0x01
 192:	fc 01       	movw	r30, r24
 194:	20 83       	st	Z, r18
}
 196:	00 00       	nop
 198:	0f 90       	pop	r0
 19a:	df 91       	pop	r29
 19c:	cf 91       	pop	r28
 19e:	08 95       	ret

000001a0 <usart_puts>:
void usart_puts(const char *send){
 1a0:	cf 93       	push	r28
 1a2:	df 93       	push	r29
 1a4:	00 d0       	rcall	.+0      	; 0x1a6 <usart_puts+0x6>
 1a6:	cd b7       	in	r28, 0x3d	; 61
 1a8:	de b7       	in	r29, 0x3e	; 62
 1aa:	9a 83       	std	Y+2, r25	; 0x02
 1ac:	89 83       	std	Y+1, r24	; 0x01
	while(*send){
 1ae:	0b c0       	rjmp	.+22     	; 0x1c6 <usart_puts+0x26>
		usart_putc(*send++);
 1b0:	89 81       	ldd	r24, Y+1	; 0x01
 1b2:	9a 81       	ldd	r25, Y+2	; 0x02
 1b4:	9c 01       	movw	r18, r24
 1b6:	2f 5f       	subi	r18, 0xFF	; 255
 1b8:	3f 4f       	sbci	r19, 0xFF	; 255
 1ba:	3a 83       	std	Y+2, r19	; 0x02
 1bc:	29 83       	std	Y+1, r18	; 0x01
 1be:	fc 01       	movw	r30, r24
 1c0:	80 81       	ld	r24, Z
 1c2:	0e 94 b5 00 	call	0x16a	; 0x16a <usart_putc>
	;
	/*Put data into the buffer and send */
	UDR1 = cdata;
}
void usart_puts(const char *send){
	while(*send){
 1c6:	89 81       	ldd	r24, Y+1	; 0x01
 1c8:	9a 81       	ldd	r25, Y+2	; 0x02
 1ca:	fc 01       	movw	r30, r24
 1cc:	80 81       	ld	r24, Z
 1ce:	88 23       	and	r24, r24
 1d0:	79 f7       	brne	.-34     	; 0x1b0 <usart_puts+0x10>
		usart_putc(*send++);
	}
}
 1d2:	00 00       	nop
 1d4:	0f 90       	pop	r0
 1d6:	0f 90       	pop	r0
 1d8:	df 91       	pop	r29
 1da:	cf 91       	pop	r28
 1dc:	08 95       	ret

000001de <usart_ok>:
void usart_ok(void){
 1de:	cf 93       	push	r28
 1e0:	df 93       	push	r29
 1e2:	cd b7       	in	r28, 0x3d	; 61
 1e4:	de b7       	in	r29, 0x3e	; 62
	usart_puts("OK\r\n");
 1e6:	80 e0       	ldi	r24, 0x00	; 0
 1e8:	91 e0       	ldi	r25, 0x01	; 1
 1ea:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
}
 1ee:	00 00       	nop
 1f0:	df 91       	pop	r29
 1f2:	cf 91       	pop	r28
 1f4:	08 95       	ret

000001f6 <__vector_25>:
ISR(USART1_RX_vect){
 1f6:	1f 92       	push	r1
 1f8:	0f 92       	push	r0
 1fa:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 1fe:	0f 92       	push	r0
 200:	11 24       	eor	r1, r1
 202:	2f 93       	push	r18
 204:	3f 93       	push	r19
 206:	4f 93       	push	r20
 208:	5f 93       	push	r21
 20a:	6f 93       	push	r22
 20c:	7f 93       	push	r23
 20e:	8f 93       	push	r24
 210:	9f 93       	push	r25
 212:	af 93       	push	r26
 214:	bf 93       	push	r27
 216:	ef 93       	push	r30
 218:	ff 93       	push	r31
 21a:	cf 93       	push	r28
 21c:	df 93       	push	r29
 21e:	cd b7       	in	r28, 0x3d	; 61
 220:	de b7       	in	r29, 0x3e	; 62
	data_in[data_count] = UDR1;
 222:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <data_count>
 226:	88 2f       	mov	r24, r24
 228:	90 e0       	ldi	r25, 0x00	; 0
 22a:	2e ec       	ldi	r18, 0xCE	; 206
 22c:	30 e0       	ldi	r19, 0x00	; 0
 22e:	f9 01       	movw	r30, r18
 230:	20 81       	ld	r18, Z
 232:	83 5a       	subi	r24, 0xA3	; 163
 234:	9e 4f       	sbci	r25, 0xFE	; 254
 236:	fc 01       	movw	r30, r24
 238:	20 83       	st	Z, r18
	usart_putc(UDR1);
 23a:	8e ec       	ldi	r24, 0xCE	; 206
 23c:	90 e0       	ldi	r25, 0x00	; 0
 23e:	fc 01       	movw	r30, r24
 240:	80 81       	ld	r24, Z
 242:	0e 94 b5 00 	call	0x16a	; 0x16a <usart_putc>
	
	if(data_in[data_count] == '\n' || data_in[data_count] == '\r'){
 246:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <data_count>
 24a:	88 2f       	mov	r24, r24
 24c:	90 e0       	ldi	r25, 0x00	; 0
 24e:	83 5a       	subi	r24, 0xA3	; 163
 250:	9e 4f       	sbci	r25, 0xFE	; 254
 252:	fc 01       	movw	r30, r24
 254:	80 81       	ld	r24, Z
 256:	8a 30       	cpi	r24, 0x0A	; 10
 258:	51 f0       	breq	.+20     	; 0x26e <__vector_25+0x78>
 25a:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <data_count>
 25e:	88 2f       	mov	r24, r24
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	83 5a       	subi	r24, 0xA3	; 163
 264:	9e 4f       	sbci	r25, 0xFE	; 254
 266:	fc 01       	movw	r30, r24
 268:	80 81       	ld	r24, Z
 26a:	8d 30       	cpi	r24, 0x0D	; 13
 26c:	31 f4       	brne	.+12     	; 0x27a <__vector_25+0x84>
		command_ready = TRUE;
 26e:	81 e0       	ldi	r24, 0x01	; 1
 270:	80 93 7d 01 	sts	0x017D, r24	; 0x80017d <command_ready>
		data_count = 0;
 274:	10 92 4c 01 	sts	0x014C, r1	; 0x80014c <data_count>
 278:	05 c0       	rjmp	.+10     	; 0x284 <__vector_25+0x8e>
		}else{
		data_count++;
 27a:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <data_count>
 27e:	8f 5f       	subi	r24, 0xFF	; 255
 280:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <data_count>
	}
}
 284:	00 00       	nop
 286:	df 91       	pop	r29
 288:	cf 91       	pop	r28
 28a:	ff 91       	pop	r31
 28c:	ef 91       	pop	r30
 28e:	bf 91       	pop	r27
 290:	af 91       	pop	r26
 292:	9f 91       	pop	r25
 294:	8f 91       	pop	r24
 296:	7f 91       	pop	r23
 298:	6f 91       	pop	r22
 29a:	5f 91       	pop	r21
 29c:	4f 91       	pop	r20
 29e:	3f 91       	pop	r19
 2a0:	2f 91       	pop	r18
 2a2:	0f 90       	pop	r0
 2a4:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
 2a8:	0f 90       	pop	r0
 2aa:	1f 90       	pop	r1
 2ac:	18 95       	reti

000002ae <command_copy>:

void command_copy(void){
 2ae:	cf 93       	push	r28
 2b0:	df 93       	push	r29
 2b2:	00 d0       	rcall	.+0      	; 0x2b4 <command_copy+0x6>
 2b4:	cd b7       	in	r28, 0x3d	; 61
 2b6:	de b7       	in	r29, 0x3e	; 62
	ATOMIC_BLOCK(ATOMIC_FORCEON){
 2b8:	1a 82       	std	Y+2, r1	; 0x02
 2ba:	0e 94 75 00 	call	0xea	; 0xea <__iCliRetVal>
 2be:	89 83       	std	Y+1, r24	; 0x01
 2c0:	12 c0       	rjmp	.+36     	; 0x2e6 <command_copy+0x38>
		memcpy(command_in, data_in, CMDLEN);
 2c2:	80 e1       	ldi	r24, 0x10	; 16
 2c4:	ed e5       	ldi	r30, 0x5D	; 93
 2c6:	f1 e0       	ldi	r31, 0x01	; 1
 2c8:	ad e4       	ldi	r26, 0x4D	; 77
 2ca:	b1 e0       	ldi	r27, 0x01	; 1
 2cc:	01 90       	ld	r0, Z+
 2ce:	0d 92       	st	X+, r0
 2d0:	8a 95       	dec	r24
 2d2:	e1 f7       	brne	.-8      	; 0x2cc <command_copy+0x1e>
		//Clear data_in for next console command
		
		memset(data_in, 0, CMDLEN);
 2d4:	40 e1       	ldi	r20, 0x10	; 16
 2d6:	50 e0       	ldi	r21, 0x00	; 0
 2d8:	60 e0       	ldi	r22, 0x00	; 0
 2da:	70 e0       	ldi	r23, 0x00	; 0
 2dc:	8d e5       	ldi	r24, 0x5D	; 93
 2de:	91 e0       	ldi	r25, 0x01	; 1
 2e0:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <memset>
		data_count++;
	}
}

void command_copy(void){
	ATOMIC_BLOCK(ATOMIC_FORCEON){
 2e4:	19 82       	std	Y+1, r1	; 0x01
 2e6:	89 81       	ldd	r24, Y+1	; 0x01
 2e8:	88 23       	and	r24, r24
 2ea:	59 f7       	brne	.-42     	; 0x2c2 <command_copy+0x14>
 2ec:	ce 01       	movw	r24, r28
 2ee:	02 96       	adiw	r24, 0x02	; 2
 2f0:	0e 94 7e 00 	call	0xfc	; 0xfc <__iSeiParam>
		memcpy(command_in, data_in, CMDLEN);
		//Clear data_in for next console command
		
		memset(data_in, 0, CMDLEN);
	}
}
 2f4:	00 00       	nop
 2f6:	0f 90       	pop	r0
 2f8:	0f 90       	pop	r0
 2fa:	df 91       	pop	r29
 2fc:	cf 91       	pop	r28
 2fe:	08 95       	ret

00000300 <parse_assignment>:
int parse_assignment(void){
 300:	cf 93       	push	r28
 302:	df 93       	push	r29
 304:	cd b7       	in	r28, 0x3d	; 61
 306:	de b7       	in	r29, 0x3e	; 62
 308:	64 97       	sbiw	r28, 0x14	; 20
 30a:	0f b6       	in	r0, 0x3f	; 63
 30c:	f8 94       	cli
 30e:	de bf       	out	0x3e, r29	; 62
 310:	0f be       	out	0x3f, r0	; 63
 312:	cd bf       	out	0x3d, r28	; 61
	char *pch;
	char cmdValue[CMDLEN] = {0};
 314:	20 e1       	ldi	r18, 0x10	; 16
 316:	ce 01       	movw	r24, r28
 318:	05 96       	adiw	r24, 0x05	; 5
 31a:	fc 01       	movw	r30, r24
 31c:	32 2f       	mov	r19, r18
 31e:	11 92       	st	Z+, r1
 320:	3a 95       	dec	r19
 322:	e9 f7       	brne	.-6      	; 0x31e <parse_assignment+0x1e>
	int retVal = 0;
 324:	1a 82       	std	Y+2, r1	; 0x02
 326:	19 82       	std	Y+1, r1	; 0x01
	// Find the position the equals sign is
	// in the string, keep a pointer to it
	pch = strchr(command_in, '=');
 328:	6d e3       	ldi	r22, 0x3D	; 61
 32a:	70 e0       	ldi	r23, 0x00	; 0
 32c:	8d e4       	ldi	r24, 0x4D	; 77
 32e:	91 e0       	ldi	r25, 0x01	; 1
 330:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <strchr>
 334:	9c 83       	std	Y+4, r25	; 0x04
 336:	8b 83       	std	Y+3, r24	; 0x03
	// Copy everything after that point into
	// the buffer variable
	strcpy(cmdValue, pch+1);
 338:	8b 81       	ldd	r24, Y+3	; 0x03
 33a:	9c 81       	ldd	r25, Y+4	; 0x04
 33c:	9c 01       	movw	r18, r24
 33e:	2f 5f       	subi	r18, 0xFF	; 255
 340:	3f 4f       	sbci	r19, 0xFF	; 255
 342:	ce 01       	movw	r24, r28
 344:	05 96       	adiw	r24, 0x05	; 5
 346:	b9 01       	movw	r22, r18
 348:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <strcpy>
	// Now turn this value into an integer and
	// return it to the caller.
	retVal = atoi(cmdValue);
 34c:	ce 01       	movw	r24, r28
 34e:	05 96       	adiw	r24, 0x05	; 5
 350:	0e 94 c4 02 	call	0x588	; 0x588 <atoi>
 354:	9a 83       	std	Y+2, r25	; 0x02
 356:	89 83       	std	Y+1, r24	; 0x01
	//Copy current command for future queries
	strcpy(last_command, command_in);
 358:	6d e4       	ldi	r22, 0x4D	; 77
 35a:	71 e0       	ldi	r23, 0x01	; 1
 35c:	8d e6       	ldi	r24, 0x6D	; 109
 35e:	91 e0       	ldi	r25, 0x01	; 1
 360:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <strcpy>
	return retVal;
 364:	89 81       	ldd	r24, Y+1	; 0x01
 366:	9a 81       	ldd	r25, Y+2	; 0x02
}
 368:	64 96       	adiw	r28, 0x14	; 20
 36a:	0f b6       	in	r0, 0x3f	; 63
 36c:	f8 94       	cli
 36e:	de bf       	out	0x3e, r29	; 62
 370:	0f be       	out	0x3f, r0	; 63
 372:	cd bf       	out	0x3d, r28	; 61
 374:	df 91       	pop	r29
 376:	cf 91       	pop	r28
 378:	08 95       	ret

0000037a <parse_query>:
int parse_query(void){
 37a:	cf 93       	push	r28
 37c:	df 93       	push	r29
 37e:	cd b7       	in	r28, 0x3d	; 61
 380:	de b7       	in	r29, 0x3e	; 62
 382:	64 97       	sbiw	r28, 0x14	; 20
 384:	0f b6       	in	r0, 0x3f	; 63
 386:	f8 94       	cli
 388:	de bf       	out	0x3e, r29	; 62
 38a:	0f be       	out	0x3f, r0	; 63
 38c:	cd bf       	out	0x3d, r28	; 61
	char *pch;
	char cmdValue[CMDLEN] = {0};
 38e:	20 e1       	ldi	r18, 0x10	; 16
 390:	ce 01       	movw	r24, r28
 392:	05 96       	adiw	r24, 0x05	; 5
 394:	fc 01       	movw	r30, r24
 396:	32 2f       	mov	r19, r18
 398:	11 92       	st	Z+, r1
 39a:	3a 95       	dec	r19
 39c:	e9 f7       	brne	.-6      	; 0x398 <parse_query+0x1e>
	int retVal = 0;
 39e:	1a 82       	std	Y+2, r1	; 0x02
 3a0:	19 82       	std	Y+1, r1	; 0x01
	// Find the position of the question mark is
	// in the string, keep a pointer to it
	pch = strchr(last_command, '=');
 3a2:	6d e3       	ldi	r22, 0x3D	; 61
 3a4:	70 e0       	ldi	r23, 0x00	; 0
 3a6:	8d e6       	ldi	r24, 0x6D	; 109
 3a8:	91 e0       	ldi	r25, 0x01	; 1
 3aa:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <strchr>
 3ae:	9c 83       	std	Y+4, r25	; 0x04
 3b0:	8b 83       	std	Y+3, r24	; 0x03
	// Copy everything after that point into
	// the buffer variable
	strcpy(cmdValue, pch+1);
 3b2:	8b 81       	ldd	r24, Y+3	; 0x03
 3b4:	9c 81       	ldd	r25, Y+4	; 0x04
 3b6:	9c 01       	movw	r18, r24
 3b8:	2f 5f       	subi	r18, 0xFF	; 255
 3ba:	3f 4f       	sbci	r19, 0xFF	; 255
 3bc:	ce 01       	movw	r24, r28
 3be:	05 96       	adiw	r24, 0x05	; 5
 3c0:	b9 01       	movw	r22, r18
 3c2:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <strcpy>
	// Now turn this value into an integer and
	// return it to the caller.
	retVal = atoi(cmdValue);
 3c6:	ce 01       	movw	r24, r28
 3c8:	05 96       	adiw	r24, 0x05	; 5
 3ca:	0e 94 c4 02 	call	0x588	; 0x588 <atoi>
 3ce:	9a 83       	std	Y+2, r25	; 0x02
 3d0:	89 83       	std	Y+1, r24	; 0x01
//	memset(command_in, 0, CMDLEN);
	return retVal;
 3d2:	89 81       	ldd	r24, Y+1	; 0x01
 3d4:	9a 81       	ldd	r25, Y+2	; 0x02
}
 3d6:	64 96       	adiw	r28, 0x14	; 20
 3d8:	0f b6       	in	r0, 0x3f	; 63
 3da:	f8 94       	cli
 3dc:	de bf       	out	0x3e, r29	; 62
 3de:	0f be       	out	0x3f, r0	; 63
 3e0:	cd bf       	out	0x3d, r28	; 61
 3e2:	df 91       	pop	r29
 3e4:	cf 91       	pop	r28
 3e6:	08 95       	ret

000003e8 <print_val>:
void print_val(char id, int value){
 3e8:	cf 93       	push	r28
 3ea:	df 93       	push	r29
 3ec:	cd b7       	in	r28, 0x3d	; 61
 3ee:	de b7       	in	r29, 0x3e	; 62
 3f0:	63 97       	sbiw	r28, 0x13	; 19
 3f2:	0f b6       	in	r0, 0x3f	; 63
 3f4:	f8 94       	cli
 3f6:	de bf       	out	0x3e, r29	; 62
 3f8:	0f be       	out	0x3f, r0	; 63
 3fa:	cd bf       	out	0x3d, r28	; 61
 3fc:	89 8b       	std	Y+17, r24	; 0x11
 3fe:	7b 8b       	std	Y+19, r23	; 0x13
 400:	6a 8b       	std	Y+18, r22	; 0x12
	char buffer[16];
	usart_puts(RETURN_NEWLINE);
 402:	85 e0       	ldi	r24, 0x05	; 5
 404:	91 e0       	ldi	r25, 0x01	; 1
 406:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
	itoa(value, buffer, 10);
 40a:	8a 89       	ldd	r24, Y+18	; 0x12
 40c:	9b 89       	ldd	r25, Y+19	; 0x13
 40e:	4a e0       	ldi	r20, 0x0A	; 10
 410:	50 e0       	ldi	r21, 0x00	; 0
 412:	9e 01       	movw	r18, r28
 414:	2f 5f       	subi	r18, 0xFF	; 255
 416:	3f 4f       	sbci	r19, 0xFF	; 255
 418:	b9 01       	movw	r22, r18
 41a:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <itoa>
	usart_putc(id);
 41e:	89 89       	ldd	r24, Y+17	; 0x11
 420:	0e 94 b5 00 	call	0x16a	; 0x16a <usart_putc>
	usart_putc(COLON);
 424:	8a e3       	ldi	r24, 0x3A	; 58
 426:	0e 94 b5 00 	call	0x16a	; 0x16a <usart_putc>
	usart_puts(buffer);
 42a:	ce 01       	movw	r24, r28
 42c:	01 96       	adiw	r24, 0x01	; 1
 42e:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
	usart_puts(RETURN_NEWLINE);
 432:	85 e0       	ldi	r24, 0x05	; 5
 434:	91 e0       	ldi	r25, 0x01	; 1
 436:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
}
 43a:	00 00       	nop
 43c:	63 96       	adiw	r28, 0x13	; 19
 43e:	0f b6       	in	r0, 0x3f	; 63
 440:	f8 94       	cli
 442:	de bf       	out	0x3e, r29	; 62
 444:	0f be       	out	0x3f, r0	; 63
 446:	cd bf       	out	0x3d, r28	; 61
 448:	df 91       	pop	r29
 44a:	cf 91       	pop	r28
 44c:	08 95       	ret

0000044e <process_command>:

void process_command(void){
 44e:	cf 93       	push	r28
 450:	df 93       	push	r29
 452:	cd b7       	in	r28, 0x3d	; 61
 454:	de b7       	in	r29, 0x3e	; 62

	switch(command_in[0])
 456:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <command_in>
 45a:	88 2f       	mov	r24, r24
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	82 34       	cpi	r24, 0x42	; 66
 460:	91 05       	cpc	r25, r1
 462:	21 f0       	breq	.+8      	; 0x46c <process_command+0x1e>
 464:	83 34       	cpi	r24, 0x43	; 67
 466:	91 05       	cpc	r25, r1
 468:	c1 f1       	breq	.+112    	; 0x4da <process_command+0x8c>
 46a:	6e c0       	rjmp	.+220    	; 0x548 <process_command+0xfa>
	{
		case 'B':
		if (command_in[1] == '='){
 46c:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <command_in+0x1>
 470:	8d 33       	cpi	r24, 0x3D	; 61
 472:	89 f4       	brne	.+34     	; 0x496 <process_command+0x48>
			sensitivity = parse_assignment();
 474:	0e 94 80 01 	call	0x300	; 0x300 <parse_assignment>
 478:	90 93 4b 01 	sts	0x014B, r25	; 0x80014b <__data_end+0x1>
 47c:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <__data_end>
			print_val(command_in[0], sensitivity);
 480:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <__data_end>
 484:	90 91 4b 01 	lds	r25, 0x014B	; 0x80014b <__data_end+0x1>
 488:	20 91 4d 01 	lds	r18, 0x014D	; 0x80014d <command_in>
 48c:	bc 01       	movw	r22, r24
 48e:	82 2f       	mov	r24, r18
 490:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <print_val>
			print_val(last_command[0], sensitivity);
			
			}else{
			usart_puts("Invalid command\n\r");
		}
		break;
 494:	5e c0       	rjmp	.+188    	; 0x552 <process_command+0x104>
		case 'B':
		if (command_in[1] == '='){
			sensitivity = parse_assignment();
			print_val(command_in[0], sensitivity);
			
			} else if (command_in[1] == '?'){
 496:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <command_in+0x1>
 49a:	8f 33       	cpi	r24, 0x3F	; 63
 49c:	c9 f4       	brne	.+50     	; 0x4d0 <process_command+0x82>
			usart_puts(RETURN_NEWLINE);
 49e:	85 e0       	ldi	r24, 0x05	; 5
 4a0:	91 e0       	ldi	r25, 0x01	; 1
 4a2:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
			usart_puts("Brightness Query \n\r");
 4a6:	88 e0       	ldi	r24, 0x08	; 8
 4a8:	91 e0       	ldi	r25, 0x01	; 1
 4aa:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
			sensitivity = parse_query();
 4ae:	0e 94 bd 01 	call	0x37a	; 0x37a <parse_query>
 4b2:	90 93 4b 01 	sts	0x014B, r25	; 0x80014b <__data_end+0x1>
 4b6:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <__data_end>
			print_val(last_command[0], sensitivity);
 4ba:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <__data_end>
 4be:	90 91 4b 01 	lds	r25, 0x014B	; 0x80014b <__data_end+0x1>
 4c2:	20 91 6d 01 	lds	r18, 0x016D	; 0x80016d <last_command>
 4c6:	bc 01       	movw	r22, r24
 4c8:	82 2f       	mov	r24, r18
 4ca:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <print_val>
			
			}else{
			usart_puts("Invalid command\n\r");
		}
		break;
 4ce:	41 c0       	rjmp	.+130    	; 0x552 <process_command+0x104>
			usart_puts("Brightness Query \n\r");
			sensitivity = parse_query();
			print_val(last_command[0], sensitivity);
			
			}else{
			usart_puts("Invalid command\n\r");
 4d0:	8c e1       	ldi	r24, 0x1C	; 28
 4d2:	91 e0       	ldi	r25, 0x01	; 1
 4d4:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
		}
		break;
 4d8:	3c c0       	rjmp	.+120    	; 0x552 <process_command+0x104>
		
		case 'C':
		if (command_in[1] == '='){
 4da:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <command_in+0x1>
 4de:	8d 33       	cpi	r24, 0x3D	; 61
 4e0:	89 f4       	brne	.+34     	; 0x504 <process_command+0xb6>
			sensitivity = parse_assignment();
 4e2:	0e 94 80 01 	call	0x300	; 0x300 <parse_assignment>
 4e6:	90 93 4b 01 	sts	0x014B, r25	; 0x80014b <__data_end+0x1>
 4ea:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <__data_end>
			print_val(command_in[0], sensitivity);
 4ee:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <__data_end>
 4f2:	90 91 4b 01 	lds	r25, 0x014B	; 0x80014b <__data_end+0x1>
 4f6:	20 91 4d 01 	lds	r18, 0x014D	; 0x80014d <command_in>
 4fa:	bc 01       	movw	r22, r24
 4fc:	82 2f       	mov	r24, r18
 4fe:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <print_val>
			
			}else{
			usart_puts("Invalid command\n\r");
		}
		
		break;
 502:	27 c0       	rjmp	.+78     	; 0x552 <process_command+0x104>
		case 'C':
		if (command_in[1] == '='){
			sensitivity = parse_assignment();
			print_val(command_in[0], sensitivity);
			
			} else if (command_in[1] == '?'){
 504:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <command_in+0x1>
 508:	8f 33       	cpi	r24, 0x3F	; 63
 50a:	c9 f4       	brne	.+50     	; 0x53e <process_command+0xf0>
			usart_puts(RETURN_NEWLINE);
 50c:	85 e0       	ldi	r24, 0x05	; 5
 50e:	91 e0       	ldi	r25, 0x01	; 1
 510:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
			usart_puts("C Query \n\r");
 514:	8e e2       	ldi	r24, 0x2E	; 46
 516:	91 e0       	ldi	r25, 0x01	; 1
 518:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
			sensitivity = parse_query();
 51c:	0e 94 bd 01 	call	0x37a	; 0x37a <parse_query>
 520:	90 93 4b 01 	sts	0x014B, r25	; 0x80014b <__data_end+0x1>
 524:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <__data_end>
			print_val(command_in[0], sensitivity);
 528:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <__data_end>
 52c:	90 91 4b 01 	lds	r25, 0x014B	; 0x80014b <__data_end+0x1>
 530:	20 91 4d 01 	lds	r18, 0x014D	; 0x80014d <command_in>
 534:	bc 01       	movw	r22, r24
 536:	82 2f       	mov	r24, r18
 538:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <print_val>
			
			}else{
			usart_puts("Invalid command\n\r");
		}
		
		break;
 53c:	0a c0       	rjmp	.+20     	; 0x552 <process_command+0x104>
			usart_puts("C Query \n\r");
			sensitivity = parse_query();
			print_val(command_in[0], sensitivity);
			
			}else{
			usart_puts("Invalid command\n\r");
 53e:	8c e1       	ldi	r24, 0x1C	; 28
 540:	91 e0       	ldi	r25, 0x01	; 1
 542:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
		}
		
		break;
 546:	05 c0       	rjmp	.+10     	; 0x552 <process_command+0x104>
		
		default:
		usart_puts("Invalid command\n\r");
 548:	8c e1       	ldi	r24, 0x1C	; 28
 54a:	91 e0       	ldi	r25, 0x01	; 1
 54c:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
		break;
 550:	00 00       	nop
	}
}
 552:	00 00       	nop
 554:	df 91       	pop	r29
 556:	cf 91       	pop	r28
 558:	08 95       	ret

0000055a <main>:


int main(void)
{
 55a:	cf 93       	push	r28
 55c:	df 93       	push	r29
 55e:	cd b7       	in	r28, 0x3d	; 61
 560:	de b7       	in	r29, 0x3e	; 62
    /* Replace with your application code */
	uart_init();
 562:	0e 94 8c 00 	call	0x118	; 0x118 <uart_init>
	usart_puts("Hello, World!\n\r");
 566:	89 e3       	ldi	r24, 0x39	; 57
 568:	91 e0       	ldi	r25, 0x01	; 1
 56a:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <usart_puts>
	usart_ok();
 56e:	0e 94 ef 00 	call	0x1de	; 0x1de <usart_ok>
	
    while (1) 
    {
		if (command_ready == TRUE) {
 572:	80 91 7d 01 	lds	r24, 0x017D	; 0x80017d <command_ready>
 576:	81 30       	cpi	r24, 0x01	; 1
 578:	e1 f7       	brne	.-8      	; 0x572 <main+0x18>
			// Here is where we will copy
			command_copy();
 57a:	0e 94 57 01 	call	0x2ae	; 0x2ae <command_copy>
			// and parse the command.
			process_command();
 57e:	0e 94 27 02 	call	0x44e	; 0x44e <process_command>
			command_ready = FALSE;
 582:	10 92 7d 01 	sts	0x017D, r1	; 0x80017d <command_ready>
		}
    }
 586:	f5 cf       	rjmp	.-22     	; 0x572 <main+0x18>

00000588 <atoi>:
 588:	fc 01       	movw	r30, r24
 58a:	88 27       	eor	r24, r24
 58c:	99 27       	eor	r25, r25
 58e:	e8 94       	clt
 590:	21 91       	ld	r18, Z+
 592:	20 32       	cpi	r18, 0x20	; 32
 594:	e9 f3       	breq	.-6      	; 0x590 <atoi+0x8>
 596:	29 30       	cpi	r18, 0x09	; 9
 598:	10 f0       	brcs	.+4      	; 0x59e <atoi+0x16>
 59a:	2e 30       	cpi	r18, 0x0E	; 14
 59c:	c8 f3       	brcs	.-14     	; 0x590 <atoi+0x8>
 59e:	2b 32       	cpi	r18, 0x2B	; 43
 5a0:	41 f0       	breq	.+16     	; 0x5b2 <atoi+0x2a>
 5a2:	2d 32       	cpi	r18, 0x2D	; 45
 5a4:	39 f4       	brne	.+14     	; 0x5b4 <atoi+0x2c>
 5a6:	68 94       	set
 5a8:	04 c0       	rjmp	.+8      	; 0x5b2 <atoi+0x2a>
 5aa:	0e 94 11 03 	call	0x622	; 0x622 <__mulhi_const_10>
 5ae:	82 0f       	add	r24, r18
 5b0:	91 1d       	adc	r25, r1
 5b2:	21 91       	ld	r18, Z+
 5b4:	20 53       	subi	r18, 0x30	; 48
 5b6:	2a 30       	cpi	r18, 0x0A	; 10
 5b8:	c0 f3       	brcs	.-16     	; 0x5aa <atoi+0x22>
 5ba:	1e f4       	brtc	.+6      	; 0x5c2 <atoi+0x3a>
 5bc:	90 95       	com	r25
 5be:	81 95       	neg	r24
 5c0:	9f 4f       	sbci	r25, 0xFF	; 255
 5c2:	08 95       	ret

000005c4 <memset>:
 5c4:	dc 01       	movw	r26, r24
 5c6:	01 c0       	rjmp	.+2      	; 0x5ca <memset+0x6>
 5c8:	6d 93       	st	X+, r22
 5ca:	41 50       	subi	r20, 0x01	; 1
 5cc:	50 40       	sbci	r21, 0x00	; 0
 5ce:	e0 f7       	brcc	.-8      	; 0x5c8 <memset+0x4>
 5d0:	08 95       	ret

000005d2 <strchr>:
 5d2:	fc 01       	movw	r30, r24
 5d4:	81 91       	ld	r24, Z+
 5d6:	86 17       	cp	r24, r22
 5d8:	21 f0       	breq	.+8      	; 0x5e2 <strchr+0x10>
 5da:	88 23       	and	r24, r24
 5dc:	d9 f7       	brne	.-10     	; 0x5d4 <strchr+0x2>
 5de:	99 27       	eor	r25, r25
 5e0:	08 95       	ret
 5e2:	31 97       	sbiw	r30, 0x01	; 1
 5e4:	cf 01       	movw	r24, r30
 5e6:	08 95       	ret

000005e8 <strcpy>:
 5e8:	fb 01       	movw	r30, r22
 5ea:	dc 01       	movw	r26, r24
 5ec:	01 90       	ld	r0, Z+
 5ee:	0d 92       	st	X+, r0
 5f0:	00 20       	and	r0, r0
 5f2:	e1 f7       	brne	.-8      	; 0x5ec <strcpy+0x4>
 5f4:	08 95       	ret

000005f6 <itoa>:
 5f6:	45 32       	cpi	r20, 0x25	; 37
 5f8:	51 05       	cpc	r21, r1
 5fa:	20 f4       	brcc	.+8      	; 0x604 <itoa+0xe>
 5fc:	42 30       	cpi	r20, 0x02	; 2
 5fe:	10 f0       	brcs	.+4      	; 0x604 <itoa+0xe>
 600:	0c 94 06 03 	jmp	0x60c	; 0x60c <__itoa_ncheck>
 604:	fb 01       	movw	r30, r22
 606:	10 82       	st	Z, r1
 608:	cb 01       	movw	r24, r22
 60a:	08 95       	ret

0000060c <__itoa_ncheck>:
 60c:	bb 27       	eor	r27, r27
 60e:	4a 30       	cpi	r20, 0x0A	; 10
 610:	31 f4       	brne	.+12     	; 0x61e <__itoa_ncheck+0x12>
 612:	99 23       	and	r25, r25
 614:	22 f4       	brpl	.+8      	; 0x61e <__itoa_ncheck+0x12>
 616:	bd e2       	ldi	r27, 0x2D	; 45
 618:	90 95       	com	r25
 61a:	81 95       	neg	r24
 61c:	9f 4f       	sbci	r25, 0xFF	; 255
 61e:	0c 94 1a 03 	jmp	0x634	; 0x634 <__utoa_common>

00000622 <__mulhi_const_10>:
 622:	7a e0       	ldi	r23, 0x0A	; 10
 624:	97 9f       	mul	r25, r23
 626:	90 2d       	mov	r25, r0
 628:	87 9f       	mul	r24, r23
 62a:	80 2d       	mov	r24, r0
 62c:	91 0d       	add	r25, r1
 62e:	11 24       	eor	r1, r1
 630:	08 95       	ret

00000632 <__utoa_ncheck>:
 632:	bb 27       	eor	r27, r27

00000634 <__utoa_common>:
 634:	fb 01       	movw	r30, r22
 636:	55 27       	eor	r21, r21
 638:	aa 27       	eor	r26, r26
 63a:	88 0f       	add	r24, r24
 63c:	99 1f       	adc	r25, r25
 63e:	aa 1f       	adc	r26, r26
 640:	a4 17       	cp	r26, r20
 642:	10 f0       	brcs	.+4      	; 0x648 <__utoa_common+0x14>
 644:	a4 1b       	sub	r26, r20
 646:	83 95       	inc	r24
 648:	50 51       	subi	r21, 0x10	; 16
 64a:	b9 f7       	brne	.-18     	; 0x63a <__utoa_common+0x6>
 64c:	a0 5d       	subi	r26, 0xD0	; 208
 64e:	aa 33       	cpi	r26, 0x3A	; 58
 650:	08 f0       	brcs	.+2      	; 0x654 <__utoa_common+0x20>
 652:	a9 5d       	subi	r26, 0xD9	; 217
 654:	a1 93       	st	Z+, r26
 656:	00 97       	sbiw	r24, 0x00	; 0
 658:	79 f7       	brne	.-34     	; 0x638 <__utoa_common+0x4>
 65a:	b1 11       	cpse	r27, r1
 65c:	b1 93       	st	Z+, r27
 65e:	11 92       	st	Z+, r1
 660:	cb 01       	movw	r24, r22
 662:	0c 94 33 03 	jmp	0x666	; 0x666 <strrev>

00000666 <strrev>:
 666:	dc 01       	movw	r26, r24
 668:	fc 01       	movw	r30, r24
 66a:	67 2f       	mov	r22, r23
 66c:	71 91       	ld	r23, Z+
 66e:	77 23       	and	r23, r23
 670:	e1 f7       	brne	.-8      	; 0x66a <strrev+0x4>
 672:	32 97       	sbiw	r30, 0x02	; 2
 674:	04 c0       	rjmp	.+8      	; 0x67e <strrev+0x18>
 676:	7c 91       	ld	r23, X
 678:	6d 93       	st	X+, r22
 67a:	70 83       	st	Z, r23
 67c:	62 91       	ld	r22, -Z
 67e:	ae 17       	cp	r26, r30
 680:	bf 07       	cpc	r27, r31
 682:	c8 f3       	brcs	.-14     	; 0x676 <strrev+0x10>
 684:	08 95       	ret

00000686 <_exit>:
 686:	f8 94       	cli

00000688 <__stop_program>:
 688:	ff cf       	rjmp	.-2      	; 0x688 <__stop_program>
